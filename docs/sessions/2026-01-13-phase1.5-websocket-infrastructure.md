# Session: Phase 1.5 - WebSocket Infrastructure

**Date:** 2026-01-13
**Phase:** 1.5 Foundation
**Status:** Complete

---

## Objective

Add WebSocket support for real-time agent progress updates during pipeline execution. Enable frontend to display live status as agents run sequentially.

---

## What Was Built

### 1. Backend WebSocket Infrastructure (`src/backend/main.py`)

#### ConnectionManager Class
- Manages active WebSocket connections by session_id
- `connect(session_id, websocket)` - Accept new connection
- `disconnect(session_id)` - Remove connection
- `send_message(session_id, message)` - Send JSON to specific session
- Handles connection errors gracefully (auto-disconnect on send failure)
- Global `manager` instance for use across endpoints

#### WebSocket Endpoint
- `WS /ws/pipeline/{session_id}` - WebSocket endpoint for pipeline progress
- Client connects with session_id (UUID from frontend)
- Maintains connection while pipeline runs
- Supports ping/pong heartbeat (30s interval from client)
- Auto-reconnect support (up to 3 attempts)

### 2. Modified PipelineOrchestrator (`src/backend/services/pipeline.py`)

#### New Parameters
- `websocket_session_id: Optional[str]` - Session ID for WebSocket updates
- `connection_manager: Optional[Any]` - Connection manager instance
- Pipeline works with or without WebSocket (backwards compatible)

#### Progress Events Emitted
1. **pipeline_started** - Pipeline begins execution
   - `question`: User's question
   - `timestamp`: ISO timestamp

2. **agent_started** - Agent begins processing
   - `agent_name`: Name of agent (topic_finder, source_checker, etc.)
   - `timestamp`: ISO timestamp

3. **agent_completed** - Agent finishes processing
   - `agent_name`: Name of agent
   - `duration`: Execution time in seconds
   - `success`: Whether agent succeeded
   - `timestamp`: ISO timestamp

4. **pipeline_completed** - Pipeline finishes successfully
   - `duration`: Total pipeline execution time
   - `timestamp`: ISO timestamp

5. **pipeline_failed** - Pipeline failed with error
   - `error`: Error message
   - `duration`: Time until failure
   - `timestamp`: ISO timestamp

#### Helper Method
- `_emit_progress()` - Internal method to send progress events
- Only sends if both session_id and connection_manager are provided
- Non-blocking: pipeline works without WebSocket

### 3. Updated Test Endpoint (`src/backend/main.py`)

#### PipelineTestRequest Model
- Added `websocket_session_id: Optional[str]` field
- Backward compatible (field is optional)

#### POST /api/pipeline/test
- Accepts optional `websocket_session_id` in request body
- Passes session_id and connection_manager to orchestrator
- Still returns complete result via HTTP response
- WebSocket provides real-time updates, HTTP provides final result

### 4. Frontend WebSocket Client (`src/frontend/src/services/websocket.ts`)

#### PipelineWebSocketClient Class
- TypeScript class for WebSocket connection management
- Constructor takes session_id (UUID)
- Auto-detects WebSocket URL (ws:// or wss:// based on protocol)
- Environment variable support: `VITE_WS_URL`

#### Connection Management
- `connect()` - Async connection with Promise
- `close()` - Clean shutdown
- `isConnected()` - Check connection state
- Auto-reconnect on disconnect (up to 3 attempts, exponential backoff)

#### Event Handling
- `onProgress(handler)` - Register event handler
- `offProgress(handler)` - Remove event handler
- Typed `ProgressEvent` union for all event types
- JSON parsing with error handling

#### Heartbeat
- `ping()` - Send ping message
- Auto-ping every 30 seconds to keep connection alive
- Stops ping on disconnect

### 5. Frontend Pipeline Hook (`src/frontend/src/hooks/usePipeline.ts`)

#### usePipeline() Hook
- Custom React hook for pipeline execution with WebSocket
- Manages WebSocket connection lifecycle
- Tracks agent progress state
- Integrates with API client

#### State Management
- `isRunning` - Pipeline execution status
- `isConnecting` - WebSocket connection status
- `agentProgress[]` - Array of agent statuses
- `error` - Error message if any
- `result` - Final pipeline result
- `pipelineDuration` - Total execution time

#### Agent Progress Tracking
- Status: pending → running → completed/failed
- Timing: startTime, endTime, duration per agent
- AGENT_ORDER: Fixed order of 5 agents

#### Methods
- `runPipeline(question)` - Execute pipeline with WebSocket
- `reset()` - Clear state for new execution
- Auto-cleanup on unmount

#### Workflow
1. Generate session_id (crypto.randomUUID())
2. Create WebSocket connection
3. Call API endpoint with session_id
4. Receive real-time progress via WebSocket
5. Get final result via HTTP response
6. Close WebSocket

### 6. API Client Update (`src/frontend/src/services/api.ts`)

#### New Method
- `runPipeline(question, websocketSessionId?)` - Call pipeline test endpoint
- Accepts optional websocketSessionId parameter
- Returns pipeline result

### 7. Progress Display Component (`src/frontend/src/components/PipelineProgress.tsx`)

#### PipelineProgress Component
- Displays real-time agent progress
- Shows pipeline status (Connecting/Running/Completed)
- Lists all 5 agents with status icons
- Displays timing for completed agents
- Error display if pipeline fails

#### Status Icons
- ⏱️ Pending
- ⚙️ Running
- ✅ Completed
- ❌ Failed

#### Agent Labels
- topic_finder → "Topic Finder"
- source_checker → "Source Checker"
- adversarial_checker → "Adversarial Checker"
- writing_agent → "Writing Agent"
- publisher → "Publisher"

#### Styling (`PipelineProgress.css`)
- Color-coded status badges
- Pulse animation for running agent
- Dark mode support
- Responsive layout

---

## File Structure Created

```
src/backend/
├── main.py                           # Modified (WebSocket endpoint, ConnectionManager)
└── services/
    └── pipeline.py                   # Modified (WebSocket events)

src/frontend/src/
├── services/
│   ├── api.ts                       # Modified (runPipeline method)
│   └── websocket.ts                 # Created (WebSocket client)
├── hooks/
│   └── usePipeline.ts               # Created (React hook)
└── components/
    ├── PipelineProgress.tsx         # Created (Progress display)
    └── PipelineProgress.css         # Created (Styles)
```

---

## Key Design Decisions

1. **Optional WebSocket:** Pipeline works with or without WebSocket connection
2. **Session-Based:** Frontend generates UUID session_id for connection tracking
3. **Dual Response:** WebSocket for real-time updates, HTTP for final result
4. **Typed Events:** TypeScript union types for all progress events
5. **Auto-Reconnect:** Client attempts reconnection on disconnect (up to 3 times)
6. **Heartbeat:** Ping/pong every 30s to keep connection alive
7. **Clean Shutdown:** Explicit close on completion/error
8. **Fail Gracefully:** Backend continues if WebSocket send fails

---

## What's NOT Included (By Design)

- Full chat UI (Phase 2)
- Multiple simultaneous pipeline executions
- WebSocket authentication/authorization
- Pipeline pause/resume functionality
- Detailed per-agent progress messages (e.g., "Searching sources...")
- WebSocket connection pooling

---

## Dependencies

No new dependencies added:
- `websockets==12.0` - Already in requirements.txt
- FastAPI native WebSocket support
- Browser native WebSocket API

---

## Testing Notes

### Backend Testing

**1. Start backend:**
```bash
cd src/backend
source venv/bin/activate
uvicorn main:app --host 0.0.0.0 --port 8008
```

**2. Test WebSocket connection:**
```bash
# Use wscat or similar WebSocket client
wscat -c ws://localhost:8008/ws/pipeline/test-session-123
```

**3. Test pipeline with WebSocket:**
```bash
curl -X POST http://localhost:8008/api/pipeline/test \
  -H "Content-Type: application/json" \
  -d '{
    "question": "Did the historical Jesus exist?",
    "websocket_session_id": "test-session-123"
  }'
```

**Expected:**
- WebSocket receives progress events in real-time
- HTTP request waits until pipeline completes
- Final result returned via HTTP response

### Frontend Testing

**1. Import and use the hook:**
```tsx
import { usePipeline } from './hooks/usePipeline';
import { PipelineProgress } from './components/PipelineProgress';

function TestPage() {
  const {
    isRunning,
    isConnecting,
    agentProgress,
    error,
    result,
    pipelineDuration,
    runPipeline,
    reset
  } = usePipeline();

  return (
    <div>
      <button onClick={() => runPipeline('Test question')} disabled={isRunning}>
        Run Pipeline
      </button>
      <PipelineProgress
        agentProgress={agentProgress}
        isRunning={isRunning}
        isConnecting={isConnecting}
        error={error}
        pipelineDuration={pipelineDuration}
      />
      {result && <pre>{JSON.stringify(result, null, 2)}</pre>}
    </div>
  );
}
```

**2. Start frontend:**
```bash
cd src/frontend
npm run dev -- --host 0.0.0.0
```

**Expected:**
- Progress bar shows "Connecting..." briefly
- Each agent shows running status with animation
- Completed agents show duration
- Final result appears when pipeline completes

---

## Known Issues / Future Work

1. **No Progress Messages:** Agents only send started/completed, no intermediate progress
2. **No Cancel/Abort:** User cannot stop pipeline once started
3. **Single Connection:** Multiple tabs would create separate WebSocket connections
4. **No Retry UI:** Failed pipeline requires manual retry
5. **Environment Variable:** VITE_WS_URL needs documentation for deployment

---

## Next Steps (Phase 2)

1. Save claim cards to database
2. Implement question decomposer
3. Add semantic search for existing claims
4. Build full chat UI using WebSocket infrastructure
5. Add embedding generation during pipeline

---

## Success Criteria ✓

- [x] Backend WebSocket endpoint with connection manager
- [x] PipelineOrchestrator emits progress events
- [x] Test endpoint accepts websocket_session_id
- [x] Frontend WebSocket client with auto-reconnect
- [x] React hook for pipeline execution
- [x] Progress display component with styling
- [x] Pipeline works with or without WebSocket
- [x] No new dependencies required

---

## Files Modified

**Backend:**
- `src/backend/main.py` (ConnectionManager, WebSocket endpoint, updated test endpoint)
- `src/backend/services/pipeline.py` (WebSocket events, progress emission)

**Frontend:**
- `src/frontend/src/services/api.ts` (runPipeline method)
- `src/frontend/src/services/websocket.ts` (Created)
- `src/frontend/src/hooks/usePipeline.ts` (Created)
- `src/frontend/src/components/PipelineProgress.tsx` (Created)
- `src/frontend/src/components/PipelineProgress.css` (Created)

**Not Modified:**
- `requirements.txt` (websockets already present)
- `CLAUDE.md` (per user instruction)

---

## Architecture Notes

### WebSocket Message Flow

```
Frontend                    Backend
   |                           |
   |---- WS Connect ---------> |  (ConnectionManager.connect)
   |                           |
   |---- HTTP POST ----------> |  (POST /api/pipeline/test)
   |                           |
   | <--- pipeline_started --- |
   | <--- agent_started ------ |
   |      (topic_finder)       |
   | <--- agent_completed ---- |
   | <--- agent_started ------ |
   |      (source_checker)     |
   | <--- agent_completed ---- |
   |          ...              |
   | <--- pipeline_completed - |
   |                           |
   | <--- HTTP Response ------ |  (Final result)
   |                           |
   |---- WS Close -----------> |  (ConnectionManager.disconnect)
```

### Event Types

All events include `type` and `timestamp` fields:

```typescript
// Progress events
pipeline_started     { question }
agent_started        { agent_name }
agent_completed      { agent_name, duration, success }
pipeline_completed   { duration }
pipeline_failed      { error, duration }

// Heartbeat
pong                 {}
```

### Agent Status Lifecycle

```
pending → running → completed
                  → failed
```

---

## Session Duration

Approximately 60 minutes (all files created/modified in single session)

---

## End of Session Notes

WebSocket infrastructure complete and ready for testing. User should:
1. Test WebSocket connection independently
2. Test pipeline with WebSocket progress
3. Test frontend component integration
4. Verify auto-reconnect behavior
5. Check dark mode styling

Infrastructure is now in place for Phase 2 chat UI development.
