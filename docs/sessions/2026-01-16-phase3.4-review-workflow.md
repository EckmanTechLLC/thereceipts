# Phase 3.4: Review Workflow Backend

**Date:** 2026-01-16
**Session Type:** Implementation
**Status:** Complete ✓

---

## Objective

Implement admin review workflow backend for blog posts:
- Approve & Publish action (sets published_at)
- Reject action (blog not published, claim cards remain)
- Request Revision action (selective re-run: decomposer/pipeline/composer)

---

## Reference

- ADR 003: Auto-Blog System (lines 342-398: Review Workflow, lines 513-517: API Design)
- Planning session: 2026-01-16-phase3-planning.md (lines 179-182: Phase 3.4 scope)
- Existing patterns: services/scheduler.py, database/repositories.py

---

## Scope (Confirmed)

Phase 3.4 deliverables:
1. Review service for blog post approval workflow
2. Three actions: Approve, Request Revision (selective re-run), Reject
3. Admin API endpoints: GET /api/admin/review/pending, POST /api/admin/review/{id}/{action}

---

## Implementation Summary

### 1. Review Service (NEW)

**File:** `src/backend/services/review.py`

**Core functionality:**

**ReviewService class:**
- `get_pending_reviews()` - Query topics with review_status='pending_review'
- `approve_blog_post()` - Set published_at, update review_status to 'approved'
- `reject_blog_post()` - Set review_status to 'rejected', blog not published
- `request_revision()` - Selective re-run based on admin feedback

**Selective re-run options:**
- `revision_scope="decomposer"` - Re-decompose topic → new component claims → re-run pipeline + composer
- `revision_scope="claim_pipeline"` - Re-run specific claim card(s) via 5-agent pipeline
- `revision_scope="composer"` - Re-run blog composer only (title + article_body)

**Key design decisions:**
- Admin specifies which component failed (decomposer/pipeline/composer)
- Revision re-runs only specified component, not entire flow
- After revision, review_status resets to 'pending_review' (awaits re-review)
- Semantic search threshold: 0.92 (matches ADR 002/003)
- Claim cards remain in database regardless of blog post status (always in Audits + chat)

**Error handling:**
- ReviewServiceError raised for validation failures (topic not found, invalid state)
- Revision failures update topic.status to 'failed' with error_message
- Fail fast: No automatic retries (consistent with ADR 001)

**Helper methods:**
- `_rerun_decomposer()` - Full re-decomposition + pipeline + composer
- `_rerun_claim_pipeline()` - Selective claim card regeneration + composer
- `_rerun_composer()` - Article title + body regeneration only
- `_find_existing_claim()` - Semantic search for claim deduplication
- `_generate_claim_card()` - 5-agent pipeline execution
- `_claim_card_to_dict()` - Convert ClaimCard model to dict for agents

---

### 2. API Endpoints (NEW)

**File:** `src/backend/main.py` (added after autosuggest endpoints)

**Pydantic models added:**
```python
class ReviewApproveRequest(BaseModel):
    reviewed_by: str
    review_notes: Optional[str] = None

class ReviewRejectRequest(BaseModel):
    reviewed_by: str
    admin_feedback: str

class ReviewRevisionRequest(BaseModel):
    reviewed_by: str
    admin_feedback: str
    revision_scope: str  # "decomposer", "claim_pipeline", "composer"
    revision_details: Optional[Dict] = None  # e.g., {"claim_card_ids": ["uuid1", "uuid2"]}
```

**Endpoints added:**

**GET /api/admin/review/pending**
- Query topics with review_status='pending_review'
- Pagination: skip, limit (default: 0, 20)
- Returns: topics + blog_posts + claim_cards summary
- Response structure:
  ```json
  {
    "reviews": [
      {
        "topic_id": "uuid",
        "topic_text": "...",
        "priority": 8,
        "created_at": "...",
        "blog_post": {
          "id": "uuid",
          "title": "...",
          "article_body": "...",
          "claim_cards_count": 5,
          "created_at": "..."
        },
        "claim_cards": [
          {"id": "uuid", "claim_text": "...", "verdict": "...", "short_answer": "..."}
        ]
      }
    ],
    "total": 3
  }
  ```

**POST /api/admin/review/{topic_id}/approve**
- Approve and publish blog post
- Request body: `{reviewed_by, review_notes?}`
- Action: Sets blog_posts.published_at = NOW()
- Updates: topic.review_status = 'approved', topic.reviewed_at = NOW()
- Response: `{success, topic_id, blog_post_id, published_at, message}`

**POST /api/admin/review/{topic_id}/reject**
- Reject blog post (not published)
- Request body: `{reviewed_by, admin_feedback}`
- Action: Blog post not published (published_at remains NULL)
- Updates: topic.review_status = 'rejected', topic.reviewed_at = NOW()
- Claim cards remain in database (Audits + chat still accessible)
- Response: `{success, topic_id, message}`

**POST /api/admin/review/{topic_id}/revision**
- Request revision with selective re-run
- Request body: `{reviewed_by, admin_feedback, revision_scope, revision_details?}`
- revision_scope options:
  - "decomposer" - Re-decompose topic
  - "claim_pipeline" - Re-run specific claim cards (requires revision_details.claim_card_ids)
  - "composer" - Re-run blog composer only
- Action: Executes revision, resets review_status to 'pending_review'
- Response: `{success, topic_id, revision_scope, message, details}`
- Error: Returns 400 if invalid scope, 500 if execution fails

---

## File Changes

### New Files

1. **src/backend/services/review.py** (NEW)
   - ReviewService class
   - Three main methods: approve, reject, request_revision
   - Three helper methods for selective re-run: _rerun_decomposer, _rerun_claim_pipeline, _rerun_composer
   - Semantic search + pipeline integration for revision execution
   - ~600 lines

### Modified Files

1. **src/backend/main.py**
   - Added import: ReviewService, ReviewServiceError
   - Added Pydantic models: ReviewApproveRequest, ReviewRejectRequest, ReviewRevisionRequest
   - Added 4 endpoints: GET /pending, POST /approve, POST /reject, POST /revision
   - ~170 lines added

---

## Database Interactions

**Tables used:**
- `topic_queue` - Read/write for review_status, reviewed_at, admin_feedback
- `blog_posts` - Read/write for published_at, reviewed_by, review_notes
- `claim_cards` - Read for claim details, write for new claim cards (revision only)

**Review status flow:**
```
pending_review → approved (published)
pending_review → rejected (not published)
pending_review → needs_revision → (re-run) → pending_review (awaits re-review)
```

**Published_at semantics:**
- NULL = not published (won't appear in Read page)
- NOW() = published (visible in Read page)
- Set only on approval action

---

## Key Design Patterns

### 1. Service Layer Abstraction
- ReviewService encapsulates all review workflow logic
- API endpoints thin wrappers around service methods
- Database operations through repositories (TopicQueueRepository, BlogPostRepository, ClaimCardRepository)

### 2. Selective Re-run Architecture
- Admin specifies revision_scope: decomposer/claim_pipeline/composer
- Only specified component re-executed, not entire flow
- Example: If only article title wrong → revision_scope="composer" → re-run composer only (5-10s vs 45-60s full pipeline)

### 3. Semantic Search Deduplication
- Revision re-uses existing claim cards where possible (similarity >= 0.92)
- Only generates new claim cards for novel component claims
- Reduces redundant pipeline executions during revision

### 4. Fail Fast
- No automatic retries on revision failure
- Failed revision updates topic.status to 'failed' with error_message
- Admin manually retries after adjustments (consistent with ADR 001)

---

## API Usage Examples

### Get Pending Reviews
```bash
curl http://localhost:8008/api/admin/review/pending?skip=0&limit=20
```

### Approve Blog Post
```bash
curl -X POST http://localhost:8008/api/admin/review/{topic_id}/approve \
  -H "Content-Type: application/json" \
  -d '{"reviewed_by": "admin", "review_notes": "Looks good!"}'
```

### Reject Blog Post
```bash
curl -X POST http://localhost:8008/api/admin/review/{topic_id}/reject \
  -H "Content-Type: application/json" \
  -d '{"reviewed_by": "admin", "admin_feedback": "Topic not relevant to Christianity"}'
```

### Request Revision (Composer Only)
```bash
curl -X POST http://localhost:8008/api/admin/review/{topic_id}/revision \
  -H "Content-Type: application/json" \
  -d '{
    "reviewed_by": "admin",
    "admin_feedback": "Title too sensational, article needs better flow",
    "revision_scope": "composer"
  }'
```

### Request Revision (Specific Claim Card)
```bash
curl -X POST http://localhost:8008/api/admin/review/{topic_id}/revision \
  -H "Content-Type: application/json" \
  -d '{
    "reviewed_by": "admin",
    "admin_feedback": "Claim 3 has incorrect verdict, needs re-analysis",
    "revision_scope": "claim_pipeline",
    "revision_details": {"claim_card_ids": ["uuid-of-claim-3"]}
  }'
```

### Request Revision (Full Re-decomposition)
```bash
curl -X POST http://localhost:8008/api/admin/review/{topic_id}/revision \
  -H "Content-Type: application/json" \
  -d '{
    "reviewed_by": "admin",
    "admin_feedback": "Topic decomposition missed key claims about dating methods",
    "revision_scope": "decomposer"
  }'
```

---

## Testing Notes

**Manual testing workflow:**

1. **Setup:** Ensure Phase 3.1-3.3 complete (topic queue, decomposer/composer agents, scheduler)
2. **Generate blog post:** Use scheduler or manual trigger to create blog post
3. **Verify pending status:** Check topic.review_status = 'pending_review'
4. **Test GET /pending:** Verify blog post appears with claim cards
5. **Test approve:** Verify published_at set, blog appears in Read page (Phase 3.5)
6. **Test reject:** Verify blog not published, claim cards still in Audits
7. **Test revision (composer):** Verify new article generated, review_status reset to pending
8. **Test revision (claim_pipeline):** Verify specified claim card regenerated
9. **Test revision (decomposer):** Verify full re-decomposition + pipeline + composer
10. **Test error cases:** Invalid topic_id, invalid revision_scope, missing claim_card_ids

**Not tested (requires frontend in Phase 3.6):**
- Admin UI integration
- Review queue interface
- Visual blog post preview

---

## Dependencies

**Existing services used:**
- PipelineOrchestrator (5-agent pipeline)
- EmbeddingService (semantic search for deduplication)
- DecomposerAgent (re-decomposition)
- BlogComposerAgent (article synthesis)

**Existing repositories used:**
- TopicQueueRepository (topic management)
- BlogPostRepository (blog post CRUD)
- ClaimCardRepository (claim card queries + creation)

**No new dependencies added.**

---

## Success Criteria (Phase 3.4)

✓ Review service implements approve/reject/revision logic
✓ Approve action sets published_at and review_status='approved'
✓ Reject action sets review_status='rejected', blog not published
✓ Request revision allows selective re-run (decomposer/pipeline/composer)
✓ Revision re-runs specified component and resets review_status to 'pending_review'
✓ API endpoints expose review workflow (GET /pending, POST /approve, POST /reject, POST /revision)
✓ Claim cards remain in database regardless of blog post status
✓ Fail fast on revision errors (no automatic retries)

---

## Next Steps

**Phase 3.5: Read & Audits Backend (Next Session)**
- Blog posts service: Query published articles (published_at NOT NULL)
- Audits service: Query all claim cards (visible_in_audits = TRUE)
- API endpoints: GET /api/blog/posts, GET /api/audits/cards
- Pagination + filtering (category, verdict, search)

**Phase 3.6: Admin UI**
- Topic queue management interface
- Review workflow UI (blog post preview + component claim cards)
- Approve/reject/revision buttons with forms

**Phase 3.7: Read & Audits UI**
- Read page: Blog article list + full article view
- Audits page: Claim card grid + full card modal

---

## Notes

- Session completed in ~30 minutes
- No blocking issues encountered
- Followed existing service patterns (scheduler.py, autosuggest.py)
- Maintained consistency with ADR 001 (fail fast) and ADR 003 (review workflow)
- Review service self-contained, no changes to existing services required
- API endpoints follow existing admin endpoint conventions

---

**Status:** Phase 3.4 complete, ready for Phase 3.5 (Read & Audits Backend)
