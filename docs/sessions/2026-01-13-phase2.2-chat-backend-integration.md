# Phase 2.2: Chat Backend Integration

**Date:** 2026-01-13
**Phase:** 2.2 - Conversational Chat Backend
**Status:** Complete

---

## Objective

Complete chat backend by integrating pipeline execution for novel claims.

**Goal:** Enable full conversational chat flow where new questions trigger pipeline generation, save results to database, and stream progress via WebSocket.

---

## Reference Documents

- `/docs/sessions/2026-01-13-phase2-planning.md` - Architecture decisions
- `/docs/sessions/2026-01-13-phase2.1-context-analyzer-semantic-search.md` - Context analysis and search
- `/src/backend/services/pipeline.py` - PipelineOrchestrator
- `/src/backend/main.py` - Existing endpoints and WebSocket infrastructure

---

## Implementation Summary

### 1. Chat Pipeline Handler
**File:** `src/backend/services/chat_pipeline.py` (new)

**Purpose:** Orchestrate pipeline execution for chat and persist results.

**Flow:**
1. Run 5-agent pipeline via PipelineOrchestrator
2. On success:
   - Save claim card to database using `create_from_pipeline_output()`
   - Generate embedding for claim_text
   - Send 'claim_card_ready' event via WebSocket
3. On failure:
   - Send 'pipeline_failed' event via WebSocket (handled by orchestrator)
   - Return error details

**Key Function:**
```python
async def run_chat_pipeline(
    question: str,
    contextualized_question: str,
    websocket_session_id: str,
    db_session: AsyncSession,
    connection_manager: Any
) -> Dict[str, Any]
```

**Features:**
- Non-blocking pipeline execution
- Automatic claim card persistence
- Embedding generation with graceful failure
- WebSocket progress updates
- Comprehensive error handling

---

### 2. Response Formatter
**File:** `src/backend/services/response_formatter.py` (new)

**Purpose:** Format responses for conversational chat UI.

**Functions:**

#### `format_claim_card_for_chat(claim_card, contextualized_question)`
Converts ClaimCard model to JSON response format.

**Returns:**
```json
{
  "type": "existing",
  "contextualized_question": "Did Luke copy Mark?",
  "claim_card": { /* full claim card object */ }
}
```

#### `format_generating_response(pipeline_id, websocket_session_id, contextualized_question)`
Formats response when pipeline is running.

**Returns:**
```json
{
  "type": "generating",
  "pipeline_id": "uuid",
  "websocket_session_id": "uuid",
  "contextualized_question": "Did Luke copy Mark?",
  "message": "Generating claim card..."
}
```

---

### 3. ClaimCardRepository Extension
**File:** `src/backend/database/repositories.py` (modified)

**New Method:** `create_from_pipeline_output(pipeline_data, question)`

**Purpose:** Create ClaimCard with all relationships from pipeline output.

**Implementation:**
- Parses pipeline_data dictionary
- Creates ClaimCard instance
- Creates related entities:
  - Sources (primary_sources + scholarly_sources)
  - ApologeticsTags (apologetics_techniques)
  - CategoryTags (category_tags)
- Builds agent_audit structure with original question
- Handles both dict and string category formats
- Returns complete ClaimCard with relationships

**Pipeline Data Structure:**
```python
{
    "claim_text": str,
    "claimant": str,
    "claim_type": str,
    "verdict": str,  # VerdictEnum value
    "short_answer": str,
    "deep_answer": str,
    "why_persists": list,
    "confidence_level": str,  # ConfidenceLevelEnum value
    "confidence_explanation": str,
    "primary_sources": [{"citation": str, "url": str, "quote_text": str}, ...],
    "scholarly_sources": [{"citation": str, "url": str, "quote_text": str}, ...],
    "apologetics_techniques": [{"technique_name": str, "description": str}, ...],
    "category_tags": [{"category_name": str, "description": str}, ...],
    "audit_summary": str,
    "limitations": list,
    "change_verdict_if": str,
}
```

---

### 4. Chat Endpoint Modification
**File:** `src/backend/main.py` (modified)

**Endpoint:** `POST /api/chat/message`

**Changes:**

**Imports Added:**
- `uuid` - For generating unique IDs
- `asyncio` - For background task execution
- `chat_pipeline` - Pipeline handler
- `response_formatter` - Response formatting

**Logic Updates:**

**Before (Phase 2.1):**
```python
if search_results:
    return {/* existing claim card */}
else:
    return {
        "type": "generating",
        "message": "Pipeline generation will be implemented in Phase 2.2."
    }
```

**After (Phase 2.2):**
```python
if search_results:
    # Return formatted existing claim card
    return format_claim_card_for_chat(best_match, contextualized_question)
else:
    # Generate unique IDs
    pipeline_id = str(uuid.uuid4())
    websocket_session_id = str(uuid.uuid4())

    # Start pipeline in background (non-blocking)
    asyncio.create_task(
        run_chat_pipeline(
            question=request.message,
            contextualized_question=contextualized_question,
            websocket_session_id=websocket_session_id,
            db_session=db,
            connection_manager=manager
        )
    )

    # Return immediately
    return format_generating_response(
        pipeline_id=pipeline_id,
        websocket_session_id=websocket_session_id,
        contextualized_question=contextualized_question
    )
```

**Key Features:**
- Non-blocking: HTTP response returns immediately
- Background pipeline: Runs via asyncio.create_task()
- WebSocket progress: Client connects with websocket_session_id
- Formatted responses: Uses response_formatter utilities

---

### 5. WebSocket Handler
**File:** `src/backend/main.py` (no changes needed)

**Why No Changes:**
Existing WebSocket handler at `/ws/pipeline/{session_id}` is already generic and handles all events:
- Pipeline progress events (from PipelineOrchestrator)
- Chat-specific events ('claim_card_ready' from chat_pipeline)
- Connection management (ConnectionManager)

**Event Types Handled:**
- `pipeline_started` - Pipeline begins
- `agent_started` - Agent begins execution
- `agent_completed` - Agent finishes
- `pipeline_completed` - Pipeline succeeds
- `pipeline_failed` - Pipeline fails
- `claim_card_ready` - Claim card saved and ready (new in Phase 2.2)

---

## Complete Flow

### Chat Message Flow (New Claim)

1. **Client sends message:**
   ```http
   POST /api/chat/message
   {
     "message": "What about Luke?",
     "conversation_history": [...]
   }
   ```

2. **Server processes:**
   - Context analyzer reformulates: "Did Luke copy Mark?"
   - Generate embedding
   - Semantic search (no match found)
   - Generate pipeline_id and websocket_session_id
   - Start pipeline in background
   - Return immediately

3. **Client receives response:**
   ```json
   {
     "type": "generating",
     "pipeline_id": "abc-123",
     "websocket_session_id": "def-456",
     "contextualized_question": "Did Luke copy Mark?"
   }
   ```

4. **Client connects WebSocket:**
   ```javascript
   ws = new WebSocket(`/ws/pipeline/${websocket_session_id}`)
   ```

5. **Server sends progress:**
   - `pipeline_started`
   - `agent_started` (topic_finder)
   - `agent_completed` (topic_finder)
   - `agent_started` (source_checker)
   - ... (continues through 5 agents)
   - `pipeline_completed`

6. **Server saves claim card:**
   - Create ClaimCard with relationships
   - Generate embedding
   - Commit to database

7. **Server sends final event:**
   ```json
   {
     "type": "claim_card_ready",
     "claim_card": {
       "id": "...",
       "claim_text": "...",
       "short_answer": "...",
       /* full claim card */
     }
   }
   ```

8. **Client displays claim card in chat thread**

---

## Error Handling

### Pipeline Failure
- Pipeline agents can fail at any stage
- PipelineOrchestrator sends 'pipeline_failed' event
- run_chat_pipeline returns success=False
- No claim card created
- Client shows error state

### Embedding Generation Failure
- Claim card still saved to database
- Warning logged (not critical failure)
- Claim card usable, just missing embedding
- Can be regenerated later via scripts/generate_embeddings.py

### Database Errors
- Transaction rolled back
- ChatPipelineError raised
- Error logged
- Client receives error via WebSocket

---

## Files Created/Modified

### Created:
- `src/backend/services/chat_pipeline.py` (~170 lines)
- `src/backend/services/response_formatter.py` (~90 lines)

### Modified:
- `src/backend/database/repositories.py` (+115 lines)
  - Added `create_from_pipeline_output()` method
- `src/backend/main.py` (+15 lines, refactored 50 lines)
  - Added imports
  - Modified chat endpoint logic
  - No WebSocket handler changes needed

**Total:** ~390 lines added/modified

---

## Testing Recommendations

### Manual Testing

1. **Existing Claim Match:**
   - Send question that matches existing claim card
   - Should return type='existing' immediately
   - Should include similarity score

2. **Novel Claim Generation:**
   - Send question with no existing match
   - Should return type='generating' immediately
   - Connect WebSocket with provided session_id
   - Verify progress events received
   - Verify 'claim_card_ready' event with full claim card
   - Verify claim card saved in database

3. **Conversation Context:**
   - Send initial question
   - Send follow-up that requires context
   - Verify contextualized_question reflects conversation history
   - Verify pipeline uses contextualized question

4. **Pipeline Failure:**
   - Trigger pipeline with invalid input
   - Verify 'pipeline_failed' event
   - Verify no claim card created
   - Verify error message displayed

5. **Database Persistence:**
   - After pipeline completes, query claim_cards table
   - Verify claim card exists with all relationships
   - Verify sources, apologetics_tags, category_tags
   - Verify embedding generated

---

## Known Limitations

1. **WebSocket Session Lifecycle:**
   - WebSocket session_id is server-generated
   - Client must connect before pipeline completes
   - Consider implementing reconnection logic (Phase 2.3)

2. **Background Task Error Handling:**
   - asyncio.create_task() failures not bubbled to endpoint
   - Errors only visible via WebSocket or logs
   - Consider adding task tracking (future enhancement)

3. **Database Session in Background Task:**
   - Background task uses same db_session
   - May have session lifecycle issues
   - Monitor for "Session is already closed" errors

4. **No Pipeline Cancellation:**
   - Once started, pipeline runs to completion
   - No mechanism to cancel in-progress pipeline
   - Could add cancellation tokens (future enhancement)

---

## Next Steps (Phase 2.3)

Phase 2.2 backend is complete. Next: Chat UI implementation.

1. **Chat UI Components:**
   - Message thread component
   - Message bubbles (user + bot)
   - Claim card rendering in chat
   - Expandable sections

2. **WebSocket Integration:**
   - Connect WebSocket on message send
   - Display real-time progress
   - Handle events (agent progress, claim_card_ready)
   - Show loading states

3. **Session State:**
   - Store conversation history in sessionStorage
   - Track websocket_session_id
   - Handle page refresh
   - "New conversation" button

4. **Error Handling:**
   - Display pipeline failures
   - Retry failed messages
   - Timeout handling

---

## Completion Checklist

- [x] Create chat_pipeline.py with run_chat_pipeline()
- [x] Create response_formatter.py
- [x] Extend ClaimCardRepository with create_from_pipeline_output()
- [x] Modify POST /api/chat/message to trigger pipeline
- [x] Verify WebSocket handler supports chat events
- [x] Document session notes

---

**Status:** Phase 2.2 Complete. Ready for Phase 2.3 (Chat UI).
